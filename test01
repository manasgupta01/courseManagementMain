<!DOCTYPE html>
<html>

<head>
    <title>PagerDuty Escalation Policies</title>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/js/select2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            /* Aligns content to the left */
            width: 100%;
        }

        .form-row {
            display: flex;
            width: 100%;
            /* Takes full width of the body */
            padding: 0 20px;
            /* Adds padding on the sides */
            box-sizing: border-box;
            /* Includes padding in width calculation */
        }

        .form-group {
            display: flex;
            flex-direction: column;
            margin-right: 20px;
            /* Space between form groups */
            flex: 1;
            /* Each form group takes equal width */
        }

        .form-group:last-child {
            margin-right: 0;
            /* Removes margin from the last form group */
        }

        .pagination-btn {
            cursor: pointer;
            margin: 0 5px;
            padding: 5px 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            color: #333;
        }

        .pagination-btn:hover {
            background-color: #e9ecef;
        }

        .active-page {
            border: 2px solid #007bff;
            /* Blue border for active page */
            background-color: #e9ecef;
            color: #007bff;
            font-weight: bold;
        }

        .pagination-div {
            text-align: center;
            margin-top: 10px;
        }

        .select2-container {
            width: 100% !important;
            /* Ensures select2 takes full width of its parent */
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            /* Adds space above the table */
            padding: 0;
            /* Removes padding to allow table to stretch fully */
            box-sizing: border-box;
            /* Includes padding in width calculation */
        }

        th,
        td {
            border: 1px solid #ccc;
            padding: 10px;
        }

        th {
            background-color: #F2F2F2;
        }

        .modal {
            display: none;
            /* Hidden by default */
            position: fixed;
            /* Stay in place */
            z-index: 1;
            /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
            overflow: auto;
            /* Enable scroll if needed */
            background-color: rgb(0, 0, 0);
            /* Fallback color */
            background-color: rgba(0, 0, 0, 0.4);
            /* Black w/ opacity */
            padding-top: 60px;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            /* Could be more or less, depending on screen size */
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .highlight {
            background-color: yellow;
        }

        .graph-container {
            width: 50%;
            margin: 0 auto;
        }


        .charts-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
        height: auto;
        gap: 20px; /* Add some space between the charts */
    }

    .chart-wrapper {
        flex: 1 1 45%;
        padding: 10px;
        box-sizing: border-box;
        max-width: 100%;
    }

    canvas {
        width: 100% !important;
        height: 100% !important;
    }

    @media (max-width: 768px) {
        .chart-wrapper {
            flex: 1 1 100%;
            height: 300px;
        }
    }

    @media (max-width: 480px) {
        .chart-wrapper {
            height: 250px;
        }
    }


    </style>
</head>

<body>
    <h2>&nbsp PD Analytics</h2>
    <div class="form-row">
        <!-- <div class="form-group">
            <label for="escalation_policies"><b>Escalation Policy</b></label>
            <select id="escalation_policies" multiple="multiple">Select Escalation Policies...</select>
        </div> -->
        <div class="form-group">
            <label for="services"><b>PD Service</b></label>
            <select id="services">
                <option value="" disabled selected>Select a service...</option>
            </select>
        </div>

        <div class="form-group">
            <label for="date-picker"><b>Date</b></label>
            <input type="date" id="date-picker">
        </div>
        <button id="fetch-incidents-btn">Fetch Incidents</button>
    </div>
    <div id="Loading-message" style="display:none;"><b>&nbsp Loading...</b></div>
    <div class="info-panel" style="display: flex; justify-content: space-between; width: 100%; margin-top: 20px;">

        <div class="info-container" style="flex: 1; text-align: center; border: 1px solid #ccc; padding: 20px;">
            <div class="info-item" style="margin-bottom: 20px;">
                <h4>NUMBER OF INCIDENTS</h4>
                <p id="incident-count" style="font-size: 36px; margin: 0;">-</p>
            </div>
            <div class="info-item">
                <h4>AVERAGE MTTR</h4>
                <p id="average-mttr" style="font-size: 36px; margin: 0;">-</p>
            </div>
        </div>

        <div class="info-item" style="flex: 1; text-align: center; border: 1px solid #ccc; padding: 20px;">
            <h4>STATUS OF INCIDENTS</h4>
            <table id="status-table" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                <tr>
                    <th>Status</th>
                    <th>Count</th>
                </tr>
                <!-- Placeholder rows -->
                <tr>
                    <td>Acknowledged</td>
                    <td id="acknowledged-count">-</td>
                </tr>
                <tr>
                    <td>Resolved</td>
                    <td id="resolved-count">-</td>
                </tr>
                <tr>
                    <td>Triggered</td>
                    <td id="triggered-count">-</td>
                </tr>
            </table>
        </div>
    </div>

    <div>
        <input type="date" id="startDate" />
        <input type="date" id="endDate" />
        <button id="fetchData">Fetch Data</button>
    </div>
    <div class="charts-container">
        <div class="chart-wrapper">
            <canvas id="incidentChart"></canvas>
        </div>
        <div class="chart-wrapper">
            <canvas id="mttrChart"></canvas>
        </div>
    </div>
    
    
    
    
    

    <h2>&nbsp INCIDENTS PER PAGERDUTY SERVICE</h2>
    <div class="service-panel" style="margin-top: 20px; width: 100%;">
        <table id="service-incidents" style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr>
                    <th>PD Service</th>
                    <th>PD ID</th>
                    <th>Incident Count</th>
                    <th>MTTR</th>
                </tr>
            </thead>
            <tbody>
                <!-- Data rows will be inserted here -->
            </tbody>
        </table>
        <div id="pagination-service" style="text-align: center; margin-top: 10px;">
            <!-- Pagination buttons will be inserted here -->
        </div>
    </div>
    <h2>&nbsp INCIDENTS PER ESCALATION POLICY</h2>
    <div class="escalation-policy-panel" style="margin-top: 20px; width: 100%;">
        <table id="escalation-policy-incidents" style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr>
                    <th>Escalation Policy</th>
                    <th>PD ID</th>
                    <th>Incident Count</th>
                </tr>
            </thead>
            <tbody>
                <!-- Data rows will be inserted here -->
            </tbody>
        </table>
        <div id="pagination-escalation-policy" style="text-align: center; margin-top: 10px;">
            <!-- Pagination buttons will be inserted here -->
        </div>
    </div>
    <h2>&nbsp Incidents</h2>
    <div class="service-panel" style="margin-top: 20px; width: 100%;">
        <table id="incidents">
            <tr>
                <th>S.No</th>
                <th>Incident Number</th>
                <th>Title</th>
                <th>Status</th>
                <th>Urgency</th>
                <th>Service ID</th>
                <th>Assignee</th>
                <th>Escalation Policy</th>
                <th>Created At</th>
                <th>Resolved Time</th>
                <th>MTTR</th>
            </tr>
        </table>
        <div id="pagination-incidents" style="text-align: center; margin-top: 10px;">
            <!-- Pagination buttons will be inserted here -->
        </div>
    </div>

    <!-- Modal for Incident Timeline -->
    <div id="incidentModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Incident Timeline</h2>
            <div id="timeline-content"></div>
        </div>
    </div>

    <script>

const last30DaysIncidentCounts = {};
const last30DaysMTTRValues = {};
const last30DaysDates = [];

// Declare global variables to hold chart instances
let incidentChartInstance = null;
let mttrChartInstance = null;

// Function to fetch the number of incidents for a specific date
async function fetchGraphIncidentsCount(date) {
    const baseDate = new Date(date);
    const since = new Date(baseDate.setHours(0, 0, 0)); // Start of the day (00:00:00)
    const until = new Date(baseDate.setHours(23, 59, 59)); // End of the day (23:59:59)

    try {
        let totalIncidents = 0;
        let offset = 0;
        while (true) {
            const response = await fetch(`https://api.pagerduty.com/incidents?statuses[]=triggered&statuses[]=acknowledged&statuses[]=resolved&since=${since.toISOString()}&until=${until.toISOString()}&limit=100&offset=${offset}`, {
                headers: {
                    'Authorization': `Token token=${TOKEN}`,
                    'Accept': 'application/vnd.pagerduty+json'
                }
            });
            const data = await response.json();
           
            totalIncidents += data.incidents.length; // Count the number of incidents
            if (data.incidents.length < 100) { // Stop if fewer than 100 incidents were returned
                break;
            }
            offset += data.limit;
        }
        return totalIncidents; // Return the total count of incidents
    } catch (error) {
        console.error('Error fetching incidents:', error);
        return 0; // Return 0 in case of error
    }
}

// Function to calculate MTTR for incidents on a specific date
async function fetchMTTRForDate(date) {
    const baseDate = new Date(date);
    const since = new Date(baseDate.setHours(0, 0, 0)); // Start of the day (00:00:00)
    const until = new Date(baseDate.setHours(23, 59, 59)); // End of the day (23:59:59)

    try {
        let totalMTTR = 0;
        let incidentCount = 0;
        let offset = 0;
        while (true) {
            const response = await fetch(`https://api.pagerduty.com/incidents?statuses[]=resolved&since=${since.toISOString()}&until=${until.toISOString()}&limit=100&offset=${offset}`, {
                headers: {
                    'Authorization': `Token token=${TOKEN}`,
                    'Accept': 'application/vnd.pagerduty+json'
                }
            });
            const data = await response.json();

            data.incidents.forEach(incident => {
                const createdAt = new Date(incident.created_at);
                const resolvedAt = new Date(incident.resolved_at);
                if (resolvedAt > createdAt) {
                    const mttr = (resolvedAt - createdAt) / (1000 * 60 * 60); // MTTR in hours
                    totalMTTR += mttr;
                    incidentCount++;
                }
            });

            if (data.incidents.length < 100) { // Stop if fewer than 100 incidents were returned
                break;
            }
            offset += data.limit;
        }

        return incidentCount > 0 ? totalMTTR / incidentCount : 0; // Return average MTTR
    } catch (error) {
        console.error('Error fetching MTTR:', error);
        return 0; // Return 0 in case of error
    }
}

// Function to fetch incident counts for multiple dates in parallel
async function fetchGraphIncidentsCountsForDates(dates) {
    const promises = dates.map(date => fetchGraphIncidentsCount(date));
    return Promise.all(promises);
}

// Function to fetch MTTR values for multiple dates in parallel
async function fetchMTTRForDates(dates) {
    const promises = dates.map(date => fetchMTTRForDate(date));
    return Promise.all(promises);
}

// Function to render the graphs
function renderGraphs(dates, incidentCounts, mttrValues) {
    // Destroy existing charts if they exist
    if (incidentChartInstance) {
        incidentChartInstance.destroy();
    }
    if (mttrChartInstance) {
        mttrChartInstance.destroy();
    }

    const ctx1 = document.getElementById('incidentChart').getContext('2d');
    const ctx2 = document.getElementById('mttrChart').getContext('2d');

    // Create the incident count chart
    incidentChartInstance = new Chart(ctx1, {
        type: 'bar',
        data: {
            labels: dates,
            datasets: [{
                label: 'Total Incidents',
                data: incidentCounts,
                backgroundColor: 'rgba(75, 192, 192, 0.5)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Number of Incidents'
                    },
                    beginAtZero: true
                }
            }
        }
    });

    // Create the MTTR chart
    mttrChartInstance = new Chart(ctx2, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [{
                label: 'Average MTTR (Hours)',
                data: mttrValues,
                backgroundColor: 'rgba(153, 102, 255, 0.5)',
                borderColor: 'rgba(153, 102, 255, 1)',
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'MTTR (Hours)'
                    },
                    beginAtZero: true
                }
            }
        }
    });
}

// Function to display graphs for a given date range
async function displayGraphsForDateRange(startDate, endDate) {
    const dates = [];
    const incidentCounts = [];
    const mttrValues = [];

    // Collect the dates for the selected range
    let currentDate = new Date(startDate);
    while (currentDate <= new Date(endDate)) {
        const dateString = currentDate.toISOString().split('T')[0];
        dates.push(dateString);
        currentDate.setDate(currentDate.getDate() + 1);
    }

    // Fetch incident counts and MTTR values for the collected dates in parallel
    const [incidentCountsData, mttrValuesData] = await Promise.all([
        fetchGraphIncidentsCountsForDates(dates),
        fetchMTTRForDates(dates)
    ]);

    // Map the fetched data to dates and counts
    incidentCountsData.forEach((count, index) => {
        incidentCounts.push(count);
    });
    mttrValuesData.forEach((mttr, index) => {
        mttrValues.push(mttr);
    });

    renderGraphs(dates, incidentCounts, mttrValues);
}

// Function to display graphs for the last 30 days and store the data
async function displayGraphsForLast30Days() {
    const today = new Date();
    const startDate = new Date(today);
    startDate.setDate(today.getDate() - 30);
    const endDate = today.toISOString().split('T')[0];

    const dates = [];
    const incidentCounts = [];
    const mttrValues = [];

    let currentDate = new Date(startDate);
    while (currentDate <= today) {
        const dateString = currentDate.toISOString().split('T')[0];
        dates.push(dateString);
        currentDate.setDate(currentDate.getDate() + 1);
    }

    const [incidentCountsData, mttrValuesData] = await Promise.all([
        fetchGraphIncidentsCountsForDates(dates),
        fetchMTTRForDates(dates)
    ]);

    incidentCountsData.forEach((count, index) => {
        const date = dates[index];
        last30DaysIncidentCounts[date] = count;
        incidentCounts.push(count);
    });
    mttrValuesData.forEach((mttr, index) => {
        const date = dates[index];
        last30DaysMTTRValues[date] = mttr;
        mttrValues.push(mttr);
    });

    last30DaysDates.push(...dates);
    renderGraphs(dates, incidentCounts, mttrValues);
}

// Initialize graphs for the last 30 days on page load
document.addEventListener('DOMContentLoaded', () => {
    displayGraphsForLast30Days();
});

// Add event listener to fetch data when the button is clicked
document.getElementById('fetchData').addEventListener('click', async () => {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;

    if (startDate && endDate) {
        const dates = [];
        const incidentCounts = [];
        const mttrValues = [];

        let currentDate = new Date(startDate);
        const endDateObj = new Date(endDate);

        while (currentDate <= endDateObj) {
            const dateString = currentDate.toISOString().split('T')[0];
            dates.push(dateString);
            currentDate.setDate(currentDate.getDate() + 1);
        }

        const [incidentCountsData, mttrValuesData] = await Promise.all([
            fetchGraphIncidentsCountsForDates(dates),
            fetchMTTRForDates(dates)
        ]);

        incidentCountsData.forEach((count, index) => {
            incidentCounts.push(count);
        });
        mttrValuesData.forEach((mttr, index) => {
            mttrValues.push(mttr);
        });

        renderGraphs(dates, incidentCounts, mttrValues);
    } else {
        console.error('Start Date and End Date must be selected');
    }
});


        const TOKEN = 'u+h9x6nsf1oB_zV12hAw'; // Use your actual API token
        const servicesDropdown = $('#services');
        const usersDropdown = $('#users');
        let allIncidents = [];  // This will hold all incidents
        let sortedServices = [];  // This will hold the sorted services array
        let sortedEscalationPolicies = [];  // This will hold the sorted escalation policies array
        let selectedEscalationPolicies = []; // This will hold the selected escalation policies

        document.addEventListener('DOMContentLoaded', function () {
            fetchEscalationPolicies();
            document.getElementById('fetch-incidents-btn').addEventListener('click', async function () {
                // const shift = document.getElementById('shift-dropdown').value;
                const date = document.getElementById('date-picker').value;
                if (!date) {
                    alert('Please select date.');
                    return;
                }
                showLoadingIndicator();
                await fetchIncidents(date);
                hideLoadingIndicator();
            });

            // Get the modal
            const modal = document.getElementById("incidentModal");

            // Get the <span> element that closes the modal
            const span = document.getElementsByClassName("close")[0];

            // When the user clicks on <span> (x), close the modal
            span.onclick = function () {
                modal.style.display = "none";
            }

            // When the user clicks anywhere outside of the modal, close it
            window.onclick = function (event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            }
        });

        function showLoadingIndicator() {
            document.getElementById('Loading-message').style.display = 'block';
        }

        function hideLoadingIndicator() {
            document.getElementById('Loading-message').style.display = 'none';
        }

        async function fetchEscalationPolicies(offset = 0) {
            try {
                const response = await fetch(`https://api.pagerduty.com/escalation_policies?limit=100&offset=${offset}&date_range=all`, {
                    headers: {
                        'Authorization': `Token token=${TOKEN}`,
                        'Accept': 'application/vnd.pagerduty+json'
                    }
                });
                const data = await response.json();
                const escalationPoliciesDropdown = document.getElementById('escalation_policies');
                data.escalation_policies.forEach(policy => {
                    const option = new Option(policy.summary, policy.id);
                    escalationPoliciesDropdown.appendChild(option);
                });
                if (data.more) {
                    await fetchEscalationPolicies(offset + data.limit);
                } else {
                    $(escalationPoliciesDropdown).select2({
                        placeholder: 'Type escalation policy name...',
                        allowClear: true,
                        matcher: function (params, option) {
                            if ($.trim(params.term) === '') {
                                return option;
                            }
                            if (option.text.toLowerCase().indexOf(params.term.toLowerCase()) > -1) {
                                return option;
                            }
                            return null;
                        }
                    });
                    $(escalationPoliciesDropdown).val(null).trigger('change');
                }
            } catch (error) {
                console.error('Error fetching escalation policies:', error);
            }
        }

        async function fetchServices(offset = 0) {
            try {
                const response = await fetch(`https://api.pagerduty.com/services?limit=100&offset=${offset}`, {
                    headers: {
                        'Authorization': `Token token=${TOKEN}`,
                        'Accept': 'application/vnd.pagerduty+json'
                    }
                });
                const data = await response.json();
                data.services.forEach(service => {
                    const option = new Option(service.name, service.id);
                    servicesDropdown.append(option);
                });
                if (data.more) {
                    await fetchServices(offset + data.limit);
                } else {
                    initializeSelect2(servicesDropdown, 'Select a service...');
                }
            } catch (error) {
                console.error('Error fetching services:', error);
            }
        }

        async function fetchUsers(offset = 0) {
            try {
                const response = await fetch(`https://api.pagerduty.com/users?limit=100&offset=${offset}`, {
                    headers: {
                        'Authorization': `Token token=${TOKEN}`,
                        'Accept': 'application/vnd.pagerduty+json'
                    }
                });
                const data = await response.json();
                const placeholderOption = new Option('Select a user', '', true, true);
                usersDropdown.append(placeholderOption);
                data.users.forEach(user => {
                    const option = new Option(user.name, user.id);
                    usersDropdown.append(option);
                });
                if (data.more) {
                    await fetchUsers(offset + data.limit);
                } else {
                    initializeSelect2(usersDropdown, 'Select a user');
                }
            } catch (error) {
                console.error('Error fetching users:', error);
            }
        }

        function initializeSelect2(dropdown, placeholder) {
            dropdown.select2({
                placeholder: placeholder,
                allowClear: true,
                matcher: function (params, option) {
                    if ($.trim(params.term) === '') {
                        return option;
                    }
                    if (option.text.toLowerCase().indexOf(params.term.toLowerCase()) > -1) {
                        return option;
                    }
                    return null;
                }
            });
        }

        fetchServices();
        fetchUsers();

        // Add event listeners for dropdown changes
        servicesDropdown.on('select2:select', function (e) {
            usersDropdown.val(null).trigger('change');
            fetchIncidentsByService(e.params.data.id);
        });

        usersDropdown.on('select2:select', function (e) {
            servicesDropdown.val(null).trigger('change');
            fetchIncidentsByUser(e.params.data.id);
        });


        async function fetchIncidents(date) {
            const baseDate = new Date(date);
            const since = new Date(baseDate.setHours(0, 0, 0)); // Start of the day (00:00:00)
            const until = new Date(baseDate.setHours(23, 59, 59)); // End of the day (23:59:59)

            try {
                let incidents = [];
                let offset = 0;
                while (true) {
                    const response = await fetch(`https://api.pagerduty.com/incidents?statuses[]=triggered&statuses[]=acknowledged&statuses[]=resolved&since=${since.toISOString()}&until=${until.toISOString()}&limit=100&offset=${offset}`, {
                        headers: {
                            'Authorization': `Token token=${TOKEN}`,
                            'Accept': 'application/vnd.pagerduty+json'
                        }
                    });
                    const data = await response.json();
                    if (data.incidents.length === 0) {
                        break;
                    }
                    incidents = incidents.concat(data.incidents);
                    offset += data.limit;
                }
                allIncidents = incidents; // Store all incidents for later filtering

                console.log(incidents);
                updateIncidentsTable(incidents, 1, 10, selectedEscalationPolicies);
            } catch (error) {
                console.error('Error fetching incidents:', error);
            }
        }


        async function fetchIncidentsForShift(since, until) {
            try {
                let incidents = [];
                let offset = 0;
                while (true) {
                    const response = await fetch(`https://api.pagerduty.com/incidents?statuses[]=triggered&statuses[]=acknowledged&statuses[]=resolved&since=${since}&until=${until}&limit=100&offset=${offset}`, {
                        headers: {
                            'Authorization': `Token token=${TOKEN}`,
                            'Accept': 'application/vnd.pagerduty+json'
                        }
                    });
                    const data = await response.json();
                    if (data.incidents.length === 0) {
                        break;
                    }
                    incidents = incidents.concat(data.incidents);
                    offset += data.limit;
                }
                return incidents;
            } catch (error) {
                console.error('Error fetching incidents:', error);
                return [];
            }
        }

        function fetchIncidentsByEscalationPolicy() {
            selectedEscalationPolicies = $('#escalation_policies').val();
            if (selectedEscalationPolicies && selectedEscalationPolicies.length > 0) {
                const selectedIncidents = allIncidents.filter(incident => selectedEscalationPolicies.includes(incident.escalation_policy.id));
                updateIncidentsTable(selectedIncidents, 1, 10, selectedEscalationPolicies);
            } else {
                // Show all incidents if no escalation policies are selected
                updateIncidentsTable(allIncidents, 1, 10, selectedEscalationPolicies);
            }
        }

        function aggregateDataByService(incidents) {
            const serviceData = {};

            incidents.forEach(incident => {
                const serviceName = incident.service.summary; // Assuming 'service' is an object with a 'summary' property
                const serviceId = incident.service.id; // Assuming 'service' has an 'id' property

                if (!serviceData[serviceName]) {
                    serviceData[serviceName] = { count: 0, id: serviceId, totalMTTR: 0, resolvedCount: 0 };
                }

                serviceData[serviceName].count++;

                if (incident.status === 'resolved' && incident.resolved_at) {
                    const createdAt = new Date(incident.created_at);
                    const resolvedAt = new Date(incident.resolved_at);
                    const mttr = resolvedAt - createdAt;

                    serviceData[serviceName].totalMTTR += mttr;
                    serviceData[serviceName].resolvedCount++;
                }
            });

            // Convert to an array, calculate average MTTR, sort by count, and return
            return Object.keys(serviceData).map(key => {
                const service = serviceData[key];
                const averageMTTRMillis = service.resolvedCount > 0 ? service.totalMTTR / service.resolvedCount : 0;
                const hours = Math.floor(averageMTTRMillis / (1000 * 60 * 60));
                const minutes = Math.floor((averageMTTRMillis % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((averageMTTRMillis % (1000 * 60)) / 1000);

                return {
                    name: key,
                    id: service.id,
                    count: service.count,
                    averageMTTR: `${hours}h ${minutes}m ${seconds}s`
                };
            }).sort((a, b) => b.count - a.count); // Sort by count in descending order
        }


        function aggregateDataByEscalationPolicy(incidents) {
            const escalationPolicyCounts = {};

            incidents.forEach(incident => {
                const escalationPolicyName = incident.escalation_policy.summary; // Assuming 'escalation_policy' is an object with a 'summary' property
                const escalationPolicyId = incident.escalation_policy.id; // Assuming 'escalation_policy' has an 'id' property

                if (!escalationPolicyCounts[escalationPolicyName]) {
                    escalationPolicyCounts[escalationPolicyName] = { count: 0, id: escalationPolicyId };
                }
                escalationPolicyCounts[escalationPolicyName].count++;
            });

            // Convert to an array, sort by count, and return
            return Object.keys(escalationPolicyCounts).map(key => ({
                name: key,
                id: escalationPolicyCounts[key].id,
                count: escalationPolicyCounts[key].count
            })).sort((a, b) => b.count - a.count); // Sort by count in descending order
        }

        function updateServiceTable(services, pageNumber, itemsPerPage) {
            const startIndex = (pageNumber - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageServices = services.slice(startIndex, endIndex);

            const tbody = $('#service-incidents tbody');
            tbody.empty();

            pageServices.forEach(service => {
                tbody.append(`
            <tr>
                <td>${service.name}</td>
                <td>${service.id}</td>
                <td>${service.count}</td>
                <td>${service.averageMTTR}</td>
            </tr>
        `);
            });

            setupPagination(services.length, itemsPerPage, pageNumber, 'service');
        }


        function updateEscalationPolicyTable(escalationPolicies, pageNumber, itemsPerPage) {
            const startIndex = (pageNumber - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageEscalationPolicies = escalationPolicies.slice(startIndex, endIndex);

            const tbody = $('#escalation-policy-incidents tbody');
            tbody.empty();

            pageEscalationPolicies.forEach(policy => {
                tbody.append(`<tr><td>${policy.name}</td><td>${policy.id}</td><td>${policy.count}</td></tr>`);
            });

            setupPagination(escalationPolicies.length, itemsPerPage, pageNumber, 'escalation-policy');
        }

        function setupPagination(totalItems, itemsPerPage, currentPage, type) {
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const paginationDiv = type === 'service' ? $('#pagination-service') : (type === 'escalation-policy' ? $('#pagination-escalation-policy') : $('#pagination-incidents'));
            paginationDiv.empty();

            // Add "Prev" button
            const prevButton = $('<button class="pagination-btn">«Prev</button>');
            prevButton.on('click', function () {
                if (currentPage > 1) {
                    if (type === 'service') {
                        updateServiceTable(sortedServices, currentPage - 1, itemsPerPage);
                    } else if (type === 'escalation-policy') {
                        updateEscalationPolicyTable(sortedEscalationPolicies, currentPage - 1, itemsPerPage);
                    } else {
                        updateIncidentsTable(allIncidents, currentPage - 1, itemsPerPage, selectedEscalationPolicies);
                    }
                }
            });
            paginationDiv.append(prevButton);

            // Calculate the range of pages to display
            const maxVisiblePages = 10;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

            // Adjust startPage if endPage is less than maxVisiblePages
            if (endPage - startPage < maxVisiblePages - 1) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const button = $(`<button class="pagination-btn">${i}</button>`);
                button.on('click', function () {
                    if (type === 'service') {
                        updateServiceTable(sortedServices, i, itemsPerPage);
                    } else if (type === 'escalation-policy') {
                        updateEscalationPolicyTable(sortedEscalationPolicies, i, itemsPerPage);
                    } else {
                        updateIncidentsTable(allIncidents, i, itemsPerPage, selectedEscalationPolicies);
                    }
                    $('.pagination-btn').removeClass('active-page'); // Remove active class from all buttons
                    $(this).addClass('active-page'); // Add active class to the clicked button
                });
                paginationDiv.append(button);
                if (i === currentPage) {
                    button.addClass('active-page');
                }
            }

            // Add "Next" button
            const nextButton = $('<button class="pagination-btn">Next»</button>');
            nextButton.on('click', function () {
                if (currentPage < totalPages) {
                    if (type === 'service') {
                        updateServiceTable(sortedServices, currentPage + 1, itemsPerPage);
                    } else if (type === 'escalation-policy') {
                        updateEscalationPolicyTable(sortedEscalationPolicies, currentPage + 1, itemsPerPage);
                    } else {
                        updateIncidentsTable(allIncidents, currentPage + 1, itemsPerPage, selectedEscalationPolicies);
                    }
                }
            });
            paginationDiv.append(nextButton);
        }

        function updateIncidentsTable(incidents, pageNumber = 1, itemsPerPage = 10, selectedEscalationPolicies = []) {
            const startIndex = (pageNumber - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            let pageIncidents = incidents.slice(startIndex, endIndex);

            if (selectedEscalationPolicies.length > 0) {
                pageIncidents = pageIncidents.filter(incident => selectedEscalationPolicies.includes(incident.escalation_policy.id));
            }

            const incidentsTable = $('#incidents');
            incidentsTable.empty();
            incidentsTable.append('<tr><th>S.No</th><th>Incident Number</th><th>Title</th><th>Status</th><th>Urgency</th><th>Service ID</th><th>Assignee</th><th>Escalation Policy</th><th>Created At (Local Time)</th><th>Resolved At (Local Time)</th><th>MTTR</th></tr>');

            if (pageIncidents.length === 0) {
                incidentsTable.append('<tr><td colspan="11">No incidents found</td></tr>');
            } else {
                pageIncidents.forEach((incident, index) => {
                    const row = $('<tr></tr>');
                    row.append(`<td><a href="#" class="incident-link" data-incident-id="${incident.id}">${startIndex + index + 1}</a></td>`);

                    ['incident_number', 'title', 'status', 'urgency', 'service', 'assignments', 'escalation_policy', 'created_at', 'resolved_at'].forEach(key => {
                        const cell = $('<td></td>');
                        if (key === 'service') {
                            cell.text(incident[key].id);
                        } else if (key === 'escalation_policy') {
                            cell.text(incident[key].summary);
                        } else if (key === 'assignments' && incident[key].length > 0) {
                            cell.text(incident[key][0].assignee.summary);
                        } else if (key === 'created_at') {
                            const localTime = new Date(incident[key]).toLocaleString();
                            cell.text(localTime);
                        } else if (key === 'resolved_at') {
                            const localTime = new Date(incident[key]).toLocaleString();
                            cell.text(localTime);
                        } else {
                            cell.text(incident[key]);
                        }
                        row.append(cell);
                    });

                    // Calculate MTTR
                    const mttrCell = $('<td></td>');
                    if (incident.resolved_at) {
                        const createdAt = new Date(incident.created_at);
                        const resolvedAt = new Date(incident.resolved_at);
                        const duration = resolvedAt - createdAt;

                        const hours = Math.floor(duration / (1000 * 60 * 60));
                        const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((duration % (1000 * 60)) / 1000);

                        mttrCell.text(`${hours}h ${minutes}m ${seconds}s`);
                    } else {
                        mttrCell.text('N/A');
                    }
                    row.append(mttrCell);

                    incidentsTable.append(row);
                });

                // Add event listeners for incident links
                $('.incident-link').on('click', function (event) {
                    event.preventDefault();
                    const incidentId = $(this).data('incident-id');
                    fetchIncidentTimeline(incidentId);
                });

                // Add hover effect for incident links
                $('.incident-link').hover(
                    function () {
                        $(this).addClass('highlight');
                    },
                    function () {
                        $(this).removeClass('highlight');
                    }
                );
            }

            setupPagination(incidents.length, itemsPerPage, pageNumber, 'incidents');
            updateInfoPanel(incidents);
            sortedServices = aggregateDataByService(incidents);  // Store sorted services
            updateServiceTable(sortedServices, 1, 10);  // Display the first page
            sortedEscalationPolicies = aggregateDataByEscalationPolicy(incidents);  // Store sorted escalation policies
            updateEscalationPolicyTable(sortedEscalationPolicies, 1, 10);  // Display the first page
        }


        function setupPagination(totalItems, itemsPerPage, currentPage, type) {
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            const paginationDiv = type === 'service' ? $('#pagination-service') : (type === 'escalation-policy' ? $('#pagination-escalation-policy') : $('#pagination-incidents'));
            paginationDiv.empty();

            // Add "Prev" button
            const prevButton = $('<button class="pagination-btn">«Prev</button>');
            prevButton.on('click', function () {
                if (currentPage > 1) {
                    if (type === 'service') {
                        updateServiceTable(sortedServices, currentPage - 1, itemsPerPage);
                    } else if (type === 'escalation-policy') {
                        updateEscalationPolicyTable(sortedEscalationPolicies, currentPage - 1, itemsPerPage);
                    } else {
                        updateIncidentsTable(allIncidents, currentPage - 1, itemsPerPage, selectedEscalationPolicies);
                    }
                }
            });
            paginationDiv.append(prevButton);

            // Calculate the range of pages to display
            const maxVisiblePages = 10;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

            // Adjust startPage if endPage is less than maxVisiblePages
            if (endPage - startPage < maxVisiblePages - 1) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const button = $(`<button class="pagination-btn">${i}</button>`);
                button.on('click', function () {
                    if (type === 'service') {
                        updateServiceTable(sortedServices, i, itemsPerPage);
                    } else if (type === 'escalation-policy') {
                        updateEscalationPolicyTable(sortedEscalationPolicies, i, itemsPerPage);
                    } else {
                        updateIncidentsTable(allIncidents, i, itemsPerPage, selectedEscalationPolicies);
                    }
                    $('.pagination-btn').removeClass('active-page'); // Remove active class from all buttons
                    $(this).addClass('active-page'); // Add active class to the clicked button
                });
                paginationDiv.append(button);
                if (i === currentPage) {
                    button.addClass('active-page');
                }
            }

            // Add "Next" button
            const nextButton = $('<button class="pagination-btn">Next»</button>');
            nextButton.on('click', function () {
                if (currentPage < totalPages) {
                    if (type === 'service') {
                        updateServiceTable(sortedServices, currentPage + 1, itemsPerPage);
                    } else if (type === 'escalation-policy') {
                        updateEscalationPolicyTable(sortedEscalationPolicies, currentPage + 1, itemsPerPage);
                    } else {
                        updateIncidentsTable(allIncidents, currentPage + 1, itemsPerPage, selectedEscalationPolicies);
                    }
                }
            });
            paginationDiv.append(nextButton);
        }
        function updateInfoPanel(incidents) {
            const statusCounts = { triggered: 0, resolved: 0, acknowledged: 0 };
            const urgencyCounts = { high: 0, low: 0, medium: 0 };

            let totalMTTR = 0;
            let resolvedCount = 0;

            incidents.forEach(incident => {
                statusCounts[incident.status] = (statusCounts[incident.status] || 0) + 1;
                urgencyCounts[incident.urgency] = (urgencyCounts[incident.urgency] || 0) + 1;

                if (incident.status === 'resolved' && incident.resolved_at) {
                    const createdAt = new Date(incident.created_at);
                    const resolvedAt = new Date(incident.resolved_at);
                    const mttr = resolvedAt - createdAt;
                    totalMTTR += mttr;
                    resolvedCount++;
                }
            });



            $('#incident-count').text(incidents.length);
            $('#high-urgency-count').text(urgencyCounts.high);
            $('#low-urgency-count').text(urgencyCounts.low);
            $('#acknowledged-count').text(statusCounts.acknowledged);
            $('#resolved-count').text(statusCounts.resolved);
            $('#triggered-count').text(statusCounts.triggered);

            // Calculate and display average MTTR
            let averageMTTR = '-';
            if (resolvedCount > 0) {
                const averageMTTRMillis = totalMTTR / resolvedCount;
                const hours = Math.floor(averageMTTRMillis / (1000 * 60 * 60));
                const minutes = Math.floor((averageMTTRMillis % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((averageMTTRMillis % (1000 * 60)) / 1000);
                averageMTTR = `${hours}h ${minutes}m ${seconds}s`;
            }
            $('#average-mttr').text(averageMTTR);
        }


        async function fetchIncidentTimeline(incidentId) {
            try {
                const response = await fetch(`https://api.pagerduty.com/incidents/${incidentId}/log_entries`, {
                    headers: {
                        'Authorization': `Token token=${TOKEN}`,
                        'Accept': 'application/vnd.pagerduty+json'
                    }
                });
                const data = await response.json();
                const timelineContent = $('#timeline-content');
                timelineContent.empty();

                // Format the date to the user's local time zone
                const formatter = new Intl.DateTimeFormat(undefined, {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short'
                });

                data.log_entries.forEach(entry => {
                    const localTime = formatter.format(new Date(entry.created_at));
                    const entryElement = $('<div></div>').text(`${localTime}: ${entry.summary}`);
                    timelineContent.append(entryElement);
                });

                $('#incidentModal').show();
            } catch (error) {
                console.error('Error fetching incident timeline:', error);
            }
        }

        // Add event listener for escalation policy selection
        $('#escalation_policies').on('select2:select select2:unselect', fetchIncidentsByEscalationPolicy);
    </script>
      
</body>

</html>
